<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>liuCodeBoy</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="liuCodeBoy">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="liuCodeBoy">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liuCodeBoy">
  
    <link rel="alternate" href="/atom.xml" title="liuCodeBoy" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">liuCodeBoy</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-细说-synchronized和dispatch-once" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/15/细说-synchronized和dispatch-once/" class="article-date">
  <time datetime="2017-09-15T10:46:33.000Z" itemprop="datePublished">2017-09-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/15/细说-synchronized和dispatch-once/">细说@synchronized和dispatch_once</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>通常我们在实现单例时候都会使用synchronized或者dispatch_once方法，初始化往往是下面的样子：<br>使用synchronized方法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">static id obj = nil;</div><div class="line">+(instancetype)shareInstance</div><div class="line">&#123;</div><div class="line">    @synchronized(self) &#123;</div><div class="line">        if (!obj) &#123;</div><div class="line">            obj = [[SingletonObj alloc] init];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用dispatch_once方法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">static id obj = nil;</div><div class="line">+(instancetype)shareInstance</div><div class="line">&#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        obj = [[SingletonObj alloc] init];</div><div class="line">    &#125;);</div><div class="line">    return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="性能差异"><a href="#性能差异" class="headerlink" title="性能差异"></a>性能差异</h3><p> 上面的这些写法大家应该都很熟悉，既然两种方式都能实现，我们来看看两者的性能差异，这里简单写了个测试的<a href="https://github.com/FreeMind-LJ/SingletonTest" target="_blank" rel="external">demo</a>，使用两个方法分单线程跟多线程(采用dispatch_apply方式，性能相对较高)去访问一个单例对象一百万次，对比这期间的耗时，从iPod跟5s测试得到如下的结果
 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//ipod，主线程</div><div class="line">    SingletonTest[4285:446820] synchronized time cost:2.202945s</div><div class="line">    SingletonTest[4285:446820] dispatch_once time cost:0.761034s</div><div class="line"></div><div class="line">    //5s，主线程</div><div class="line">    SingletonTest[5372:2394430] synchronized time cost:0.466293s</div><div class="line">    SingletonTest[5372:2394430] dispatch_once time cost:0.070822s</div><div class="line"></div><div class="line">    //ipod，多线程</div><div class="line">    SingletonTest[4315:448499] synchronized time cost:3.385109s</div><div class="line">    SingletonTest[4315:448499] dispatch_once time cost:0.908009s</div><div class="line"></div><div class="line">    //5s，多线程</div><div class="line">    SingletonTest[5391:2399069] synchronized time cost:0.507504s</div><div class="line">    SingletonTest[5391:2399069] dispatch_once time cost:0.169934s</div></pre></td></tr></table></figure>
<p> 可以发现dispatch_once方法的性能要明显优于synchronized方法(多线程不采用dispathc_apply方式差距更明显)，所以在实际的应用中我们可以多采用dispatch_once方式来实现单例。通常使用的时候了解这些就够了，不过想知道两者的具体差异就需要我们再迈进一步。</p>
<h3 id="深入-synchronized-object"><a href="#深入-synchronized-object" class="headerlink" title="深入@synchronized(object)"></a>深入@synchronized(object)</h3><p>翻看苹果的<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW3" target="_blank" rel="external">文档</a>可以发现 @synchronized指令内部使用锁来实现多线程的安全访问，并且隐式添加了一个异常处理的handler，当异常发生时会自动释放锁。在<a href="https://stackoverflow.com/questions/1215330/how-does-synchronized-lock-unlock-in-objective-c/6047218#6047218" target="_blank" rel="external">stackoverflow</a>上看到@synchronized指令其实可以转换成objc_sync_enter跟objc_sync_exit，可以在<objc objc-sync.h="">头文件中找到这两个函数:</objc></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//Allocates recursive pthread_mutex associated with &apos;obj&apos; if needed</div><div class="line">int objc_sync_enter(id obj)</div><div class="line"></div><div class="line">//End synchronizing on &apos;obj&apos;</div><div class="line">int objc_sync_exit(id obj)</div></pre></td></tr></table></figure>
<p>根据注释文档，objc_sync_enter会根据需要给每个传进来的对象创建一个互斥锁并lock，然后objc_sync_exit的时候unlock，这样就可以通过这个锁来实现多线程的安全访问，所以结合苹果文档可以认为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@synchronized(self) &#123;</div><div class="line">    //thread safe code</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@try &#123;</div><div class="line">    objc_sync_enter(self);</div><div class="line">    // thread safe code</div><div class="line">&#125; @finally &#123;</div><div class="line">    objc_sync_exit(self);    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  庆幸的是苹果已经将objc-runtime这部分开源，所以我们可以更进一步了解内部的实现，源码在<a href="https://opensource.apple.com/source/objc4/objc4-680/runtime/objc-sync.mm" target="_blank" rel="external">这里</a>，有兴趣也可以自己去查阅，这里简单介绍一下。<br>让我们先来看看几个数据结构，其中有些涉及到缓存，我们就不去考虑了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">typedef struct SyncData &#123;</div><div class="line">    struct SyncData* nextData;</div><div class="line">    DisguisedPtr&lt;objc_object&gt; object;</div><div class="line">    int32_t threadCount;  // number of THREADS using this block</div><div class="line">    recursive_mutex_t mutex;</div><div class="line">&#125; SyncData;</div><div class="line"></div><div class="line">struct SyncList &#123;</div><div class="line">    SyncData *data;</div><div class="line">    spinlock_t lock;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">#define LOCK_FOR_OBJ(obj) sDataLists[obj].lock</div><div class="line">#define LIST_FOR_OBJ(obj) sDataLists[obj].data</div><div class="line">static StripedMap&lt;SyncList&gt; sDataLists;</div></pre></td></tr></table></figure>
<p>首先看看SyncData这个数据结构，包含一个指向object的指针，这个object对象就是我们@synchronized时传进来的对象，也包含一个跟object关联的递归互斥锁recursive_mutex_t，该锁用来互斥访问object对象；同时还包含一个指向下一个SyncData的指针nextData，可以看出SyncData是一个链表中的节点；至于threadCount，这个值标示有几个线程正在访问这个对象，当threadCount==0的时候，会重用该SyncData对象，这是为了节省内存。<br>  接下来看看SyncList，SyncList其实就是一个链表，data指向第一个SyncData节点，lock则是为了多线程安全访问该链表。<br>  最后看下sDataLists静态哈希表对象，它以obj的指针为key,对应的value为SyncList链表。<br>  了解上面之后，我们就可以看看objc_sync_enter跟objc_sync_exit的具体实现（摘取部分代码）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">//根据object对象去查询相应的SyncData对象，如果没有则创建一个新的</div><div class="line">static SyncData* id2data(id object, enum usage why)</div><div class="line">&#123;</div><div class="line">    spinlock_t *lockp = &amp;LOCK_FOR_OBJ(object);</div><div class="line">    SyncData **listp = &amp;LIST_FOR_OBJ(object);</div><div class="line">    SyncData* result = NULL;</div><div class="line"></div><div class="line">    //lock，多线程安全访问SyncList</div><div class="line">    lockp-&gt;lock();</div><div class="line">    &#123;</div><div class="line">        SyncData* p;</div><div class="line">        SyncData* firstUnused = NULL;</div><div class="line">        for (p = *listp; p != NULL; p = p-&gt;nextData) &#123;</div><div class="line">            //找到object对象对应的SyncData对象，增加其threadCount计数，然后返回</div><div class="line">            if ( p-&gt;object == object ) &#123;</div><div class="line">                result = p;</div><div class="line">                OSAtomicIncrement32Barrier(&amp;result-&gt;threadCount);</div><div class="line">                goto done;</div><div class="line">            &#125;</div><div class="line">            //当threadCount == 0时，设置当前SyncData为可重用</div><div class="line">            if ( (firstUnused == NULL) &amp;&amp; (p-&gt;threadCount == 0) )</div><div class="line">                firstUnused = p;</div><div class="line">        &#125;</div><div class="line">        // 如果有可重用的节点，则使用当前SyncData节点，SyncData的object指针指向新的object对象</div><div class="line">        if ( firstUnused != NULL ) &#123;</div><div class="line">            result = firstUnused;</div><div class="line">            result-&gt;object = (objc_object *)object;</div><div class="line">            result-&gt;threadCount = 1;</div><div class="line">            goto done;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //如果没有可重用的节点，则创建一个新的SyncData节点</div><div class="line">    result = (SyncData*)calloc(sizeof(SyncData), 1);</div><div class="line"></div><div class="line">    //将新的SyncData节点的object指针指向传进来的object对象</div><div class="line">    result-&gt;object = (objc_object *)object;</div><div class="line">    result-&gt;threadCount = 1;</div><div class="line"></div><div class="line">    //创建一个新的与该object关联的递归互斥锁</div><div class="line">    new (&amp;result-&gt;mutex) recursive_mutex_t();</div><div class="line">    result-&gt;nextData = *listp;</div><div class="line">    *listp = result;</div><div class="line"></div><div class="line"> done:</div><div class="line">    lockp-&gt;unlock();</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int objc_sync_enter(id obj)</div><div class="line">&#123;</div><div class="line">    int result = OBJC_SYNC_SUCCESS;</div><div class="line">    if (obj) &#123;</div><div class="line">        //根据obj指针的哈希值查找对应的SyncData,threadcount计数加一</div><div class="line">        SyncData* data = id2data(obj, ACQUIRE);</div><div class="line"></div><div class="line">        //使用SyncData的互斥锁上锁</div><div class="line">        data-&gt;mutex.lock();</div><div class="line">    &#125; else &#123;</div><div class="line">        // @synchronized(nil) 传入nil时什么也不处理</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int objc_sync_exit(id obj)</div><div class="line">&#123;</div><div class="line">    int result = OBJC_SYNC_SUCCESS;</div><div class="line">    if (obj) &#123;</div><div class="line">        //根据obj指针的哈希值查找对应的SyncData，threadcount计数减一</div><div class="line">        SyncData* data = id2data(obj, RELEASE);</div><div class="line"></div><div class="line">        //使用SyncData的互斥锁解锁 </div><div class="line">        bool okay = data-&gt;mutex.tryUnlock();</div><div class="line">        if (!okay) &#123;</div><div class="line">           result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        // @synchronized(nil) 传入nil时什么也不处理</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单来说，调用objc_sync_enter(obj)时，会根据obj指针在哈希表sDataLists对应的链表SyncList，然后在链表中查询对应obj的SyncData对象，如果查询不到则创建一个新的SyncData对象（包含创建跟obj相关的递归互斥锁）并添加到链表中，然后使用SyncData对象上锁；调用objc_sync_exit(obj)时，使用SyncData对象解锁，因此通过这个锁便可确保@synchronized之间的代码线程安全。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/458529-1c42de5d32202095.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt=""></p>
<h3 id="深入dispatch-once"><a href="#深入dispatch-once" class="headerlink" title="深入dispatch_once"></a>深入dispatch_once</h3><p>探讨了synchronized之后，我们再来说说dispatch_once。<br><code>void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block);</code><br>  根据<a href="https://developer.apple.com/documentation/dispatch#//apple_ref/c/func/dispatch_once" target="_blank" rel="external">官方文档</a>,dispatch_once可以用来初始化一些全局的数据，它能够确保block代码在app的生命周期内仅被运行一次，而且还是线程安全的，不需要额外加锁；predicate必须指向一个全局或者静态的变量，不过使用predicate的话结果是未定义的，不过predicate有啥作用，如何实现block在整个生命周期执行一次？那我们只能从源码查找(源码地址：<a href="https://opensource.apple.com/source/libdispatch/libdispatch-84.5/src/" target="_blank" rel="external">once</a>)。<br>不过在这之前先简要介绍一下:</p>
<ul>
<li><p>bool __sync_bool_compare_and_swap (type ptr, type oldval type newval, …)<br>提供原子的比较和交换操作，如果当前值 <em>ptr == oldval，就将newval写入</em>ptr，当比较赋值操作成功后返回true</p>
</li>
<li><p>*__sync_synchronize (…)<br>调用这个函数会产生一个full <a href="https://en.wikipedia.org/wiki/Memory_barrier" target="_blank" rel="external">memory barrier</a> ，用于保证CPU按照我们代码编写的顺序来执行代码，比如：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">doJob1();</div><div class="line">doJob2();</div><div class="line">__sync_synchronize();  //Job3会在Job1跟Job2完成后才执行</div><div class="line">doJob3();</div></pre></td></tr></table></figure>
<ul>
<li>type __sync_swap(type *ptr, type value, …)</li>
</ul>
<p>提供原子交换操作的函数，交换第一个跟第二个参数的值，然后返回交换前第一个参数的旧值。</p>
<ul>
<li>_dispatch_hardware_pause()</li>
</ul>
<p>调用这个函数主要是暗示处理器不要做额外的优化处理等，提高性能，节省CPU时间。</p>
<ul>
<li>信号量</li>
</ul>
<p>信号量是一个非负整数，定义了两种原子操作：wait跟signal来进行访，信号量主要用于线程同步。当一个线程调用wait操作时，如果信号量的值大于0，则获得资源并将信号量值减一，如果等于0线程睡眠直到信号量值大于0或者超时；singal将信号量的值加1，如果这时候有正在等待的线程，唤醒该线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 创建一个信号量，其值为0        </div><div class="line">dispatch_semaphore_t sema = dispatch_semaphore_create(0);</div><div class="line">ABAddressBookRequestAccessWithCompletion(addressBook, ^(bool granted, CFErrorRef error) &#123;</div><div class="line">    //操作完成后，调用signal信号量+1</div><div class="line">    dispatch_semaphore_signal(sema);</div><div class="line">&#125;);</div><div class="line">//等待dispatch_semaphore_signal将信号量值加1后才继续运行</div><div class="line">dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);</div></pre></td></tr></table></figure>
<p>接下来看看具体代码，当我们调用dispatch_once时候，内部是调用dispatch_once_f函数，其中val就是外部传入的predicate值，ctxt为Block的指针，func则是Block内部具体实现的函数指针，由于源码比较短，所以我直接把源码贴出来(为了方便查看，有些不使用宏定义)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">struct _dispatch_once_waiter_s &#123;</div><div class="line">    volatile struct _dispatch_once_waiter_s *volatile dow_next;</div><div class="line">    _dispatch_thread_semaphore_t dow_sema;</div><div class="line">&#125;;</div><div class="line">#define DISPATCH_ONCE_DONE ((struct _dispatch_once_waiter_s *)~0l)</div><div class="line">void dispatch_once(dispatch_once_t *val, dispatch_block_t block)</div><div class="line">&#123;</div><div class="line">    struct Block_basic *bb = (void *)block;</div><div class="line">    dispatch_once_f(val, block, (void *)bb-&gt;Block_invoke);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void dispatch_once_f(dispatch_once_t *val, void *ctxt, dispatch_function_t func)</div><div class="line">&#123;</div><div class="line">    //volatile，标示该变量随时可能改变，编译器不会对访问该变量的代码进行优化，每次都从内存去读取，而不使用寄存器里的值</div><div class="line">    struct _dispatch_once_waiter_s * volatile *vval =</div><div class="line">            (struct _dispatch_once_waiter_s**)val;</div><div class="line">    struct _dispatch_once_waiter_s dow = &#123; NULL, 0 &#125;;</div><div class="line">    struct _dispatch_once_waiter_s *tail, *tmp;</div><div class="line">    _dispatch_thread_semaphore_t sema;</div><div class="line"></div><div class="line">    //第一次执行的时候，predicate的值为0，所以vval＝NULL，原子比较交换函数返回true</div><div class="line">    //然后vval指向dow(dispatch_once_waiter_s，信号量的值为0，即等待中)</div><div class="line">    if (__sync_bool_compare_and_swap(vval, NULL, &amp;dow)) &#123;</div><div class="line"></div><div class="line">        //空的宏定义，啥也不做</div><div class="line">        dispatch_atomic_acquire_barrier();</div><div class="line"></div><div class="line">        //执行dispatch_once传进来的block</div><div class="line">        _dispatch_client_callout(ctxt, func);</div><div class="line"></div><div class="line">        //后面解释</div><div class="line">        dispatch_atomic_maximally_synchronizing_barrier();</div><div class="line"></div><div class="line">        //执行完block之后，将vval的值设为DISPATCH_ONCE_DONE(即predicate设为~0l）</div><div class="line">        tmp = __sync_swap(vval, DISPATCH_ONCE_DONE);  </div><div class="line">        tail = &amp;dow;</div><div class="line"></div><div class="line">        //1.如果在block的执行过程中，没有其线程调用该函数等待，tmp的值也为&amp;dow,tail==tmp，循环的条件不满足，函数执行完毕</div><div class="line">        //2.如果在block的执行过程中，有其线程调用该函数等待，历遍信号量链表，逐个唤醒线程继续运行</div><div class="line">        while (tail != tmp) &#123;</div><div class="line">            //如果中途有其它线程将vval赋值&amp;dow，这期间dow_next值为NULL，需要等待，参见else分支的__sync_bool_compare_and_swap调用</div><div class="line">            while (!tmp-&gt;dow_next) &#123;</div><div class="line">                _dispatch_hardware_pause();</div><div class="line">            &#125;</div><div class="line">            sema = tmp-&gt;dow_sema;</div><div class="line">            tmp = (struct _dispatch_once_waiter_s*)tmp-&gt;dow_next;</div><div class="line">            _dispatch_thread_semaphore_signal(sema);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else </div><div class="line">    &#123;   </div><div class="line">        //如果vval不等NULL，走这个分支，非第一次调用dispatch_once，其它线程调用</div><div class="line">        //获取信号量，如果有信号量则返回该信号量，如果没有则在当前线程创建一个新的信号量</div><div class="line">        dow.dow_sema = _dispatch_get_thread_semaphore();</div><div class="line">        for (;;) &#123;</div><div class="line">            tmp = *vval;</div><div class="line"></div><div class="line">            //vval已经被赋值为~0l，证明block已经被执行了，退出然后调用_dispatch_put_thread_semaphore销毁信号量</div><div class="line">            if (tmp == DISPATCH_ONCE_DONE) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            //空的宏定义，啥也不做</div><div class="line">            dispatch_atomic_store_barrier();</div><div class="line"></div><div class="line">            //将当前信号量加入到信号链表中，然后线程等待，</div><div class="line">            if (__sync_bool_compare_and_swap(vval, tmp, &amp;dow)) &#123;</div><div class="line">                dow.dow_next = tmp;</div><div class="line">                _dispatch_thread_semaphore_wait(dow.dow_sema);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            //如果vval的指向值不再是tmp，可能其它线程同时进入该分支，然后调用__sync_bool_compare_and_swap原子操作将vval指向了新的节点，</div><div class="line">            //则重新开始for循环</div><div class="line">        &#125;</div><div class="line">        _dispatch_put_thread_semaphore(dow.dow_sema);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>让我们来看看dispatch_once是如何确保block只执行一次。简单来说，当线程A在调用执行block并设置predicate为DISPATCH_ONCE_DONE(~0l)期间，如果有其他线程也在调用disptach_once，则这些线程会等待，各线程对应的信号量会加入到信号量链表中，等predicate设置为DISPATCH_ONCE_DONE后，也就是block执行完了，会根据信号量链表唤醒各个线程使其继续执行。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/458529-2d1119321803ee9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>不过有一种临界情况，假如线程A在执行block，但是创建单例对象obj还未完成，这时候线程B获取该obj对象，此时obj＝nil，而线程B在线程A将predicate设为DISPATCH_ONCE_DONE之后读取predicate，这是线程B会认为单例对象已经初始化完成，然后使用空的obj对象，这就会导致错误发生。因此dispatch_once会在执行完block之后会执行dispatch_atomic_maximally_synchronizing_barrier()调用，这个调用会执行一些cpuid指令，确保线程A创建单例对象obj以及置predicate为DISPATCH_ONCE_DONE的时间TimeA大于线程B进入block并读取predicate值的时间TimeB。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#define dispatch_atomic_maximally_synchronizing_barrier() \</div><div class="line">    do &#123; unsigned long _clbr; __asm__ __volatile__( \</div><div class="line">    &quot;cpuid&quot; \</div><div class="line">    : &quot;=a&quot; (_clbr) : &quot;0&quot; (0) : &quot;ebx&quot;, &quot;ecx&quot;, &quot;edx&quot;, &quot;cc&quot;, &quot;memory&quot; \</div><div class="line">    ); &#125; while(0)</div></pre></td></tr></table></figure>
<p>  除此之外，每次调用dispatch_once的时候，都会先判断predicate的值是否是~0l(也就是DISPATCH_ONCE_DONE)，如果是则意味着block已经执行过了，便不再执行，代码如下：
  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block);</div><div class="line">#ifdef __GNUC__</div><div class="line">#define dispatch_once(x, ...) do &#123; if (__builtin_expect(*(x), ~0l) != ~0l) dispatch_once((x), (__VA_ARGS__)); &#125; while (0)</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>让我们看看这里面的__builtin_expect((x), (v))，这又是一个优化的地方。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">__builtin_expect()目的是将“分支转移”的信息提供给编译器，这样编译器可以对代码进行优化，</div><div class="line">以减少指令跳转带来的性能下降。</div><div class="line">__builtin_expect((x),1) 表示 x 的值为真的可能性更大； </div><div class="line">__builtin_expect((x),0) 表示 x 的值为假的可能性更大。</div></pre></td></tr></table></figure>
<p>由于dispatch_once的只执行block一次，所以我们更期望的是已经block已经执行完了，也就是predict的值为~0l的可能性更大。<br>  现在我们清楚dispatch_once是如何确保block只执行一次了，关键就在predict这个值，通过比较这个值等于0或者~0l来判断block是否执行过，这也就是为啥我们需要将这个值设为static或者全局的缘故，因为各个线程都要去访问这个predict，有兴趣的可以试试把predicate的初始值设为非0或者非静态全局变量会发生什么～～</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  通过上面的分析，我们知道@synchronized采用的是递归互斥锁来实现线程安全，而dispatch_once的内部则使用了很多原子操作来替代锁，以及通过信号量来实现线程同步，而且有很多针对处理器优化的地方，甚至在if判断语句上也做了优化(逼格有点高)，使得其效率有很大的提升，虽然其源码很短，但里面包含的东西却很多，所以苹果也推荐使用dispatch_once来创建单例。通过这个简短的dispatch_once，你也可以清楚为什么GCD的性能会这么高了，感兴趣可以再去看看libdispatch的其它源码。。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://opensource.apple.com/source/objc4/objc4-680/runtime/objc-sync.mm" target="_blank" rel="external">objc-sync</a><br><a href="">synchronized</a><br><a href="https://developer.apple.com/documentation/dispatch#//apple_ref/c/func/dispatch_once" target="_blank" rel="external">dispatch_once</a><br><a href="http://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html#Atomic-Builtins" target="_blank" rel="external">Built-in functions for atomic</a><br><a href="https://kernelnewbies.org/FAQ/LikelyUnlikely" target="_blank" rel="external">__builtin_expect</a> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/15/细说-synchronized和dispatch-once/" data-id="cj7ltd60o0003s16f2bv7qtrl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SDWebImage源码剖析(一)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/14/SDWebImage源码剖析(一)/" class="article-date">
  <time datetime="2017-09-14T04:05:14.000Z" itemprop="datePublished">2017-09-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/14/SDWebImage源码剖析(一)/">SDWebImage源码剖析(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>  在开发项目的过程中会用到很多第三方库，比如AFNetWorking,SDWebImage,FMDB等，但一直都没去好好的研究一下，最近刚好项目不是太紧，闲下来可以给自己充充电，先研究一下SDWebImage的底层实现，源码地址：<a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage</a><br>  介绍一下SDWebImage，我们使用较多的是它提供的UIImageView分类，支持从远程服务器下载并缓存图片。自从iOS5.0开始，NSURLCache也可以处理磁盘缓存，那么SDWebImage的优势在哪？首先NSURLCache是缓存原始数据(raw data)到磁盘或内存，因此每次使用的时候需要将原始数据转换成具体的对象，如UIImage等，这会导致额外的数据解析以及内存占用等，而SDWebImage则是缓存UIImage对象在内存，缓存在NSCache中，同时直接保存压缩过的图片到磁盘中；还有一个问题是当你第一次在UIImageView中使用image对象的时候，图片的解码是在主线程中运行的！而SDWebImage会强制将解码操作放到子线程中。下图是SDWebImage简单的类图关系：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/458529-c1788a3eb9134b64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240/format/jpg" alt=""></p>
<hr>
<p>下面从UIImageView的图片加载开始看起，Let’s go!</p>
<p>首先我们在给UIImageView设置图片的时候会调用方法：<br><code>- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder;</code><br>其中url为远程图片的地址，而placeholder为预显示的图片。<br>其实还可以添加一些额外的参数，比如图片选项SDWebImageOptions</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123;</div><div class="line">    SDWebImageRetryFailed = 1 &lt;&lt; 0,//下载失败了会再次尝试下载</div><div class="line">    WebImageLowPriority = 1 &lt;&lt; 1,//当UIScrollView等正在滚动时，延迟下载图片（放置scrollView滚动卡）</div><div class="line">    SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,//只缓存到内存中</div><div class="line">    SDWebImageProgressiveDownload = 1 &lt;&lt; 3,// 图片会边下边显示</div><div class="line">    SDWebImageRefreshCached = 1 &lt;&lt; 4,//将硬盘缓存交给系统自带的NSURLCache去处理</div><div class="line">    SDWebImageContinueInBackground = 1 &lt;&lt; 5,//后台下载</div><div class="line">    SDWebImageHandleCookies = 1 &lt;&lt; 6,// 通过设置NSMutableURLRequest.HTTPShouldHandleCookies = YES来处理存储在NSHTTPCookieStore中的cookie</div><div class="line">    SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,// 允许不受信任的SSL证书。主要用于测试目的。</div><div class="line">    SDWebImageHighPriority = 1 &lt;&lt; 8,</div><div class="line">    SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,</div><div class="line">    SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一般使用的是SDWebImageRetryFailed | SDWebImageLowPriority，下面看看具体的函数调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock </div><div class="line">&#123;</div><div class="line">    [self sd_cancelCurrentImageLoad];//取消正在下载的操作</div><div class="line">    objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);//关联该view对应的图片URL  </div><div class="line">   /*...*/ </div><div class="line">    if (url) &#123;</div><div class="line">        __weak UIImageView *wself = self;//防止retain cricle</div><div class="line">        //由SDWebImageManager负责图片的获取</div><div class="line">        id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123;</div><div class="line">              /*获取图片到主线层显示*/ </div><div class="line">        &#125;];</div><div class="line">        [self sd_setImageLoadOperation:operation forKey:@&quot;UIImageViewImageLoad&quot;];</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出图片是从服务端、内存或者硬盘获取是由SDWebImageManager管理的，这个类有几个重要的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (strong, nonatomic, readwrite) SDImageCache imageCache;//负责管理cache，涉及内存缓存和硬盘保存@property (strong, nonatomic, readwrite) SDWebImageDownloader imageDownloader;//负责从网络下载图片@property (strong, nonatomic) NSMutableArray *runningOperations;//包含所有当前正在下载的操作对象</div></pre></td></tr></table></figure>
<p>manager会根据URL先去imageCache中查找对应的图片，如果没有在使用downloader去下载，并在下载完成缓存图片到imageCache，接着看实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageOptions)options</div><div class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock</div><div class="line"> &#123;</div><div class="line">     /*...*/</div><div class="line">    //根据URL生成对应的key，没有特殊处理为[url absoluteString];</div><div class="line">    NSString *key = [self cacheKeyForURL:url];</div><div class="line">    //去imageCache中寻找图片</div><div class="line">    operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) </div><div class="line">    &#123;</div><div class="line">       /*...*/</div><div class="line">       //如果图片没有找到，或者采用的SDWebImageRefreshCached选项，则从网络下载</div><div class="line">        if ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url])) &#123;</div><div class="line">                dispatch_main_sync_safe(^&#123;</div><div class="line">                  //如果图片找到了，但是采用的SDWebImageRefreshCached选项，通知获取到了图片，并再次从网络下载，使NSURLCache重新刷新</div><div class="line">                     completedBlock(image, nil, cacheType, YES, url);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">            /*下载选项设置*/ </div><div class="line">            //使用imageDownloader开启网络下载</div><div class="line">            id &lt;SDWebImageOperation&gt; subOperation = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished) &#123;</div><div class="line">                /*...*/</div><div class="line">               if (downloadedImage &amp;&amp; finished) &#123;</div><div class="line">                     //下载完成后，先将图片保存到imageCache中，然后主线程返回</div><div class="line">                     [self.imageCache storeImage:downloadedImage recalculateFromImage:NO imageData:data forKey:key toDisk:cacheOnDisk];</div><div class="line">                        &#125;</div><div class="line">                     dispatch_main_sync_safe(^&#123;</div><div class="line">                            if (!weakOperation.isCancelled) &#123;</div><div class="line">                                completedBlock(downloadedImage, nil, SDImageCacheTypeNone, finished, url);</div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">          /*...*/</div><div class="line">       &#125;</div><div class="line">        else if (image) &#123;</div><div class="line">          //在cache中找到图片了，直接返回</div><div class="line">            dispatch_main_sync_safe(^&#123;</div><div class="line">                if (!weakOperation.isCancelled) &#123;</div><div class="line">                    completedBlock(image, nil, cacheType, YES, url);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    return operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面先看downloader从网络下载的过程，下载是放在NSOperationQueue中进行的，默认maxConcurrentOperationCount为6，timeout时间为15s：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">    __block SDWebImageDownloaderOperation *operation;</div><div class="line">    __weak SDWebImageDownloader *wself = self;</div><div class="line">    /*...*/</div><div class="line">    //防止NSURLCache和SDImageCache重复缓存</div><div class="line">    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy :NSURLRequestReloadIgnoringLocalCacheData) timeoutInterval:timeoutInterval];</div><div class="line">    request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</div><div class="line">    request.HTTPShouldUsePipelining = YES;</div><div class="line">    request.allHTTPHeaderFields = wself.HTTPHeaders;//设置http头部</div><div class="line">    //SDWebImageDownloaderOperation派生自NSOperation，负责图片下载工作</div><div class="line">    operation = [[SDWebImageDownloaderOperation alloc] initWithRequest:request</div><div class="line">                                                          options:options</div><div class="line">                                                         progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123;&#125;</div><div class="line">                                                        completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) &#123;&#125;</div><div class="line">                                                        cancelled:^&#123;&#125;];</div><div class="line">    operation.shouldDecompressImages = wself.shouldDecompressImages;//是否需要解码</div><div class="line">    if (wself.username &amp;&amp; wself.password) &#123;</div><div class="line">            operation.credential = [NSURLCredential credentialWithUser:wself.username password:wself.password persistence:NSURLCredentialPersistenceForSession];</div><div class="line">    &#125;</div><div class="line">    if (options &amp; SDWebImageDownloaderHighPriority) &#123;</div><div class="line">            operation.queuePriority = NSOperationQueuePriorityHigh;</div><div class="line">        &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;</div><div class="line">            operation.queuePriority = NSOperationQueuePriorityLow;</div><div class="line">    &#125;</div><div class="line">        [wself.downloadQueue addOperation:operation];</div><div class="line">        if (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</div><div class="line">            // 如果下载顺序是后面添加的先运行</div><div class="line">            [wself.lastAddedOperation addDependency:operation];</div><div class="line">            wself.lastAddedOperation = operation;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    return operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SDWebImageDownloaderOperation派生自NSOperation，通过NSURLConnection进行图片的下载，为了确保能够处理下载的数据，需要在后台运行runloop：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">- (void)start &#123;</div><div class="line">  /*...*/</div><div class="line">#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</div><div class="line">        //开启后台下载</div><div class="line">        if ([self shouldContinueWhenAppEntersBackground]) &#123;</div><div class="line">            __weak __typeof__ (self) wself = self;</div><div class="line">            self.backgroundTaskId = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^&#123;</div><div class="line">                __strong __typeof (wself) sself = wself;</div><div class="line">                if (sself) &#123;</div><div class="line">                    [sself cancel];</div><div class="line">                    [[UIApplication sharedApplication] endBackgroundTask:sself.backgroundTaskId];</div><div class="line">                    sself.backgroundTaskId = UIBackgroundTaskInvalid;</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">        self.executing = YES;</div><div class="line">        self.connection = [[NSURLConnection alloc] initWithRequest:self.request delegate:self startImmediately:NO];</div><div class="line">    &#125;</div><div class="line">    [self.connection start];</div><div class="line"></div><div class="line">    if (self.connection) &#123;</div><div class="line">        if (self.progressBlock) &#123;</div><div class="line">            self.progressBlock(0, NSURLResponseUnknownLength);</div><div class="line">        &#125;</div><div class="line">       //在主线程发通知，这样也保证在主线程收到通知</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:self];</div><div class="line">        &#125;);</div><div class="line">       CFRunLoopRun();//在默认模式下运行当前runlooprun，直到调用CFRunLoopStop停止运行</div><div class="line">        if (!self.isFinished) &#123;</div><div class="line">            [self.connection cancel];</div><div class="line">            [self connection:self.connection didFailWithError:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorTimedOut userInfo:@&#123;NSURLErrorFailingURLErrorKey : self.request.URL&#125;]];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</div><div class="line">    if (self.backgroundTaskId != UIBackgroundTaskInvalid) &#123;</div><div class="line">        [[UIApplication sharedApplication] endBackgroundTask:self.backgroundTaskId];</div><div class="line">        self.backgroundTaskId = UIBackgroundTaskInvalid;</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下载过程中，在代理 － (void)connection:(NSURLConnection )connection didReceiveData:(NSData )data中将接收到的数据保存到NSMutableData中，[self.imageData appendData:data]，下载完成后在该线程完成图片的解码，并在完成的completionBlock中进行imageCache的缓存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (void)connectionDidFinishLoading:(NSURLConnection *)aConnection &#123;</div><div class="line">    SDWebImageDownloaderCompletedBlock completionBlock = self.completedBlock;</div><div class="line">    @synchronized(self) &#123;</div><div class="line">        CFRunLoopStop(CFRunLoopGetCurrent());//停止当前对runloop</div><div class="line">        /*...*/</div><div class="line">        if (completionBlock) &#123;</div><div class="line">            /*...*/</div><div class="line">            UIImage *image = [UIImage sd_imageWithData:self.imageData];</div><div class="line">            NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];</div><div class="line">            image = [self scaledImageForKey:key image:image];</div><div class="line"></div><div class="line">              // Do not force decoding animated GIFs</div><div class="line">             if (!image.images) &#123;</div><div class="line">                 if (self.shouldDecompressImages) &#123;</div><div class="line">                    image = [UIImage decodedImageWithImage:image];//图片解码</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (CGSizeEqualToSize(image.size, CGSizeZero)) &#123;</div><div class="line">                completionBlock(nil, nil, [NSError errorWithDomain:@&quot;SDWebImageErrorDomain&quot; code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Downloaded image has 0 pixels&quot;&#125;], YES);</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                completionBlock(image, self.imageData, nil, YES);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    self.completionBlock = nil;</div><div class="line">    [self done];</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/14/SDWebImage源码剖析(一)/" data-id="cj7ltd60k0002s16fgqjmr02r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CoreAnimation" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/01/CoreAnimation/" class="article-date">
  <time datetime="2017-09-01T03:05:14.000Z" itemprop="datePublished">2017-09-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/01/CoreAnimation/">CoreAnimation</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>pop是Facebook在开源的一款动画引擎，看下其官方的介绍：</p>
<p><code>Pop是一款在iOS、tvOS和OS X平台通用的可扩展动画引擎。它在基本静态动画的基础上，增加了弹性以及衰减动画，这在创建真实有物里性的交互很有用。其API能够快速的整合进已有的Objective-C工程，可以对任意对象的任意属性做动画。这是一个成熟且经过测试的框架，在Paper这款优秀的app中有广泛的应用。（iOS7之后苹果也提供了Spring动画(不过CASpringAnimation iOS9才提供)以及UIDynamic物理引擎(比如碰撞以及重力等物理效果不错，有兴趣可以玩玩)）</code><br>那Pop动画引擎跟CoreAnimation有啥区别？我们先来简单了解一下苹果的CoreAnimation:</p>
<h2 id="CoreAnimation"><a href="#CoreAnimation" class="headerlink" title="CoreAnimation"></a>CoreAnimation</h2><p>先看下CoreAnimation在框架中所处的位置：<br> <img src="http://upload-images.jianshu.io/upload_images/458529-56f51bb99592b3a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt=""></p>
<p> 可以看出视图的渲染以及动画都是基于CoreAnimation框架(看名字容易以为只是动画相关)，其地位还是相当重要。我们来看下iOS在视图的渲染以及动画的各个阶段，这其中涉及到应用内部以及应用外部：</p>
<p>应用内部4个阶段：</p>
<ul>
<li>布局<br>这个阶段是用户在程序内部设置组织视图或图层的关系，比如设置view的backgroundColor、frame等属性；</li>
<li>显示<br>这是图层的寄宿图片被绘制的阶段，比如实现了-drawRect:或-drawLayer:inContext:方法，这些方法会这这个阶段执行，这些绘制方法是由CPU在应用内部同步地完成，属于离屏渲染。</li>
<li>准备<br>这个阶段，CoreAnimation框架会将渲染视图的各种属性以及动画的参数等数据准备好；同时这个阶段还会解压需要渲染的image。</li>
<li>提交<br>这是在应用内部发生的最后阶段，CoreAnimation打包准备好的所有视图/图层以及动画的属性，然后通过IPC(进程间通信)发送到render server进行显示，可以看到其实视图的渲染以及动画是在另外一个进程处理的。在iOS5和之前的版本是SpringBoard进程（同时管理着iOS的主屏），在iOS6之后的版本中叫做BackBoard。</li>
</ul>
<p>应用外部2个阶段：<br>一旦这些打包好的数据到达render server，这些数据会被反序列化成另一个叫做渲染树的图层树，根据这个树状结构，render server做如下工作：</p>
<ul>
<li>根据layer的属性值，如果图层包含动画，则计算其属性的中间插值，然后设置OpenGL几何形状（纹理化的三角形）来执行渲染</li>
<li>在屏幕上渲染可见的三角形<br>所以整个阶段包含六个阶段，如果有动画，最后两个阶段会重复的执行。前五个阶段都是通过CPU处理的，只有最后一个阶段使用GPU。而且你能控制的只有前面两个阶段：布局和显示，剩下都是CoreAnimation框架在内部进行处理。</li>
</ul>
<p>简单了解完CoreAnimaton的工作方式之后，我们在来看看pop实现动画的方式。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/01/CoreAnimation/" data-id="cj7ltd5zr0000s16ft1gv33b5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post- iOS应用程序间共享数据" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/18/ iOS应用程序间共享数据/" class="article-date">
  <time datetime="2017-07-18T04:05:14.000Z" itemprop="datePublished">2017-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/18/ iOS应用程序间共享数据/">iOS应用程序间共享数据</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们知道iOS由于沙盒的存在，应用程序不能越过自己的区域去访问别的存储空间的内容，不过可能有许多场景我们需要在应用程序之间共享数据，比如多个应用共用用户名密码进行登录等。虽然我们不能直接通过文件系统来分享数据，不过还是有些方法可以实现，为了方便说明，这里同时创建了两个工程Example1和Example2，实现这两个app之间的信息共享，Example1负责写数据，Example2负责读数据，具体的demo代码可以到<a href="https://github.com/FreeMind-LJ/SharedDataDemo" target="_blank" rel="external">这里</a>获取</p>
<h2 id="UIPasteboard"><a href="#UIPasteboard" class="headerlink" title="UIPasteboard"></a>UIPasteboard</h2><p>剪贴板是应用程序之间传递数据的简单方式，建议不要使用全局的粘贴板，而是自己根据名字创建一个新的粘贴板，防止其它地方全局拷贝的影响。然后把需要共享的内容复制到粘贴板，粘贴板的内容可以是文本、URL、图片和UIColor等，另一个app就可以根据粘贴板的名字去读取相关的信息。</p>
<p>Example1设置粘贴板的内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">UIPasteboard *pasteboard = [UIPasteboard pasteboardWithName:@&quot;myPasteboard&quot; create:YES];</div><div class="line">  pasteboard.string = @&quot;myShareData&quot;;</div></pre></td></tr></table></figure>
<p>Example2读取粘贴板的内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">UIPasteboard *pasteboard = [UIPasteboard pasteboardWithName:@&quot;myPasteboard&quot; create:NO];</div><div class="line">   NSString *content = pasteboard.string;</div></pre></td></tr></table></figure>
<h2 id="Custom-URL-Scheme"><a href="#Custom-URL-Scheme" class="headerlink" title="Custom URL Scheme"></a>Custom URL Scheme</h2><p>URL Scheme能够让我们通过自定义的协议在应用程序间传递信息，当你想要发送数据给一个实现了自定义URL Scheme的应用时，只需要创建好合适格式的URL，然后调用openURL:方法，系统就会载入注册了该scheme的应用然后将你的URL传递给他，比如如下的代码,todolist是一个其它应用注册的scheme，通过openURL便可以将服务请求发送到该应用（自定义的URL Scheme要能够唯一标示该APP，如果你的URL Scheme跟别人冲突了，那么你的app就不一定会被调起，iOS并不保证调用哪个应用）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSURL *myURL = [NSURL URLWithString:@&quot;todolist://newid=20&quot;];</div><div class="line">[[UIApplication sharedApplication] openURL:myURL];</div></pre></td></tr></table></figure>
<ul>
<li><p>注册URL Scheme</p>
<p>为了能够处理URL请求，我们需要先注册自定义的URL Scheme，只需要在Info tab下的URL Types添加即可，比如我们这里注册Example2的URL Scheme。</p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/458529-cee0e4ad11ffc587.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt=""></p>
<p>Identifier用于标示名称，为了唯一性可以采用反转域名的形式，另外我们设置URL Scheme为Example2，以及role为Viewer(Viewer表示只能读取改URL但不能修改，Editor可以对URL进行读写)，这样Example2就能够接受类似”Example2:\”的URL请求了，可以在浏览器中输入”Example2:\”链接打开app。</p>
<ul>
<li>处理URL请求</li>
</ul>
<p>当有URL请求到来时，所有的URL都会传递给你的app delegate，我们需要实现application:openURL:sourceApplication:annotation:方法来接收处理对应的URL，所以假如你想通过URL方式来传递数据，只需要将数据添加到URL中即可，另外的通过解析该URL来获取对应的数据。</p>
<p>Eaxmple1发送携带参数的URL到Example2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSString *string = @&quot;Example2://name=jiangbin#age=1&quot;;</div><div class="line">NSURL *url = [NSURL URLWithString:string];</div><div class="line">[[UIApplication sharedApplication] openURL:url];</div></pre></td></tr></table></figure>
<p>Example2处理URL请求并解析:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-(BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation</div><div class="line">&#123;</div><div class="line">    if ([[url scheme] isEqualToString:@&quot;Example2&quot;]) &#123;</div><div class="line">        NSString *content = [url resourceSpecifier];</div><div class="line">        //解析content获取数据</div><div class="line">        //...</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Shared-Keychain-Access"><a href="#Shared-Keychain-Access" class="headerlink" title="Shared Keychain Access"></a>Shared Keychain Access</h2><p>iOS的keychain提供一种安全保存信息的方式，可以保存密码等数据，而且keychain中的数据不会因为你删除app而丢失，你可以在重新安装后继续读取keychain中的数据。通常每个应用程序只允许访问自己在keychain中保存的数据，不过假如你使用同一个证书的话，不同的app也可以通过keychain来实现应用间的数据共享，之前下载百度贴吧应用的时候发现首次打开它就自动登录了，可能百度的应用之间就是通过这种方式共享用户名密码进行登录的，之前登录过百度云。</p>
<p>为了实现keychain共享数据，我们需要开启Keychain Sharing，开启方法如下，然后添加设置相同的Keychain Group，不过别忘记了添加Security.framework。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/458529-00ce1a0c8ccf752c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/458529-33c95673f2c49a7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt=""><br>Example1保存数据到keychain(为了简单使用)<a href="https://github.com/soffes/SAMKeychain" target="_blank" rel="external">SSKeychian</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)setKeyChain</div><div class="line">&#123;</div><div class="line">    [SSKeychain setPassword:@&quot;shareData&quot; forService:@&quot;myservice&quot; account:@&quot;jiangbin&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Example2读取数据</p>
<figure class="highlight plain"><figcaption><span>(IBAction)getByKeychain:(id)sender</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    NSString *myData = [SSKeychain passwordForService:@&quot;myservice&quot; account:@&quot;jiangbin&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>App Groups</p>
<p>iOS8之后苹果加入了App Groups功能，应用程序之间可以通过同一个group来共享资源，app group可以通过NSUserDefaults进行小量数据的共享，如果需要共享较大的文件可以通过NSFileCoordinator、NSFilePresenter等方式。<br>开启app groups，需要添加一个group name，app之间通过这个group共享数据：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/458529-f5aca858ca61a215.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt=""></p>
<p>Example1根据group name设置内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)setAppGroup</div><div class="line">&#123;</div><div class="line">    NSUserDefaults *myDefaults = [[NSUserDefaults alloc]</div><div class="line">                                  initWithSuiteName:@&quot;group.com.jiangbin.SharedData&quot;];</div><div class="line">    [myDefaults setObject:@&quot;shared data&quot; forKey:@&quot;mykey&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Example2根据group name读取数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)setAppGroup</div><div class="line">&#123;</div><div class="line">    NSUserDefaults *myDefaults = [[NSUserDefaults alloc]</div><div class="line">                                  initWithSuiteName:@&quot;group.com.jiangbin.SharedData&quot;];</div><div class="line">    [myDefaults setObject:@&quot;shared data&quot; forKey:@&quot;mykey&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/18/ iOS应用程序间共享数据/" data-id="cj7ltd60h0001s16flj2jt43s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-Node" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/18/iOS-Node/" class="article-date">
  <time datetime="2017-06-18T04:05:14.000Z" itemprop="datePublished">2017-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/18/iOS-Node/">iOS Node(架构篇)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="主要简介"><a href="#主要简介" class="headerlink" title="主要简介"></a>主要简介</h2><ul>
<li>View代码结构的规定</li>
<li>关于view的布局</li>
<li>何时使用storyboard，何时使用nib，何时使用代码写View</li>
<li>是否有必要让业务方统一派生ViewController？</li>
</ul>
<p>  不要在viewDidLoad里面初始化你的view然后再add，这样代码就很难看。在viewDidload里面只做addSubview的事情，然后在viewWillAppear里面做布局的事情，最后在viewDidAppear里面做Notification的监听之类的事情。至于属性的初始化，则交给getter去做。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - life cycle</span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad</div><div class="line">&#123;</div><div class="line">[<span class="keyword">super</span> viewDidLoad];</div><div class="line"><span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</div><div class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.firstTableView];</div><div class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.secondTableView];</div><div class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.firstFilterLabel];</div><div class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.secondFilterLabel];</div><div class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.cleanButton];</div><div class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.originImageView];</div><div class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.processedImageView];</div><div class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.activityIndicator];</div><div class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.takeImageButton];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated</div><div class="line">&#123;</div><div class="line">[<span class="keyword">super</span> viewWillAppear:animated];</div><div class="line"><span class="built_in">CGFloat</span> width = (<span class="keyword">self</span>.view.width - <span class="number">30</span>) / <span class="number">2.0</span>f;</div><div class="line"><span class="keyword">self</span>.originImageView.size = <span class="built_in">CGSizeMake</span>(width, width);</div><div class="line">[<span class="keyword">self</span>.originImageView topInContainer:<span class="number">70</span> shouldResize:<span class="literal">NO</span>];</div><div class="line">[<span class="keyword">self</span>.originImageView leftInContainer:<span class="number">10</span> shouldResize:<span class="literal">NO</span>];</div><div class="line"><span class="keyword">self</span>.processedImageView.size = <span class="built_in">CGSizeMake</span>(width, width);</div><div class="line">[<span class="keyword">self</span>.processedImageView right:<span class="number">10</span> FromView:<span class="keyword">self</span>.originImageView];</div><div class="line">[<span class="keyword">self</span>.processedImageView topEqualToView:<span class="keyword">self</span>.originImageView];</div><div class="line"><span class="built_in">CGFloat</span> labelWidth = <span class="keyword">self</span>.view.width - <span class="number">100</span>;</div><div class="line"><span class="keyword">self</span>.firstFilterLabel.size = <span class="built_in">CGSizeMake</span>(labelWidth, <span class="number">20</span>);</div><div class="line">[<span class="keyword">self</span>.firstFilterLabel leftInContainer:<span class="number">10</span> shouldResize:<span class="literal">NO</span>];</div><div class="line">[<span class="keyword">self</span>.firstFilterLabel top:<span class="number">10</span> FromView:<span class="keyword">self</span>.originImageView];</div><div class="line">... ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每一个delegate都把对应的protocol名字带上，delegate方法不要到处乱写，写到一块区域里面去</p>
<p>比如UITableViewDelegate的方法集就老老实实写上#pragma mark - UITableViewDelegate。这样有个好处就是，当其他人阅读一个他并不熟悉的Delegate实现方法时，他只要按住command然后去点这个protocol名字，Xcode就能够立刻跳转到对应这个Delegate的protocol定义的那部分代码去，就省得他到处找了。</p>
<p>event response专门开一个代码区域</p>
<p>所有button、gestureRecognizer的响应事件都放在这个区域里面，不要到处乱放。</p>
<p>关于private methods，正常情况下ViewController里面不应该写</p>
<p>不是delegate方法的，不是event response方法的，不是life cycle方法的，就是private method了。对的，正常情况下ViewController里面一般是不会存在private methods的，这个private methods一般是用于日期换算、图片裁剪啥的这种小功能。这种小功能要么把它写成一个category，要么把他做成一个模块，哪怕这个模块只有一个函数也行。</p>
<p>ViewController基本上是大部分业务的载体，本身代码已经相当复杂，所以跟业务关联不大的东西能不放在ViewController里面就不要放。另外一点，这个private method的功能这时候只是你用得到，但是将来说不定别的地方也会用到，一开始就独立出来，有利于将来的代码复用。</p>
<h2 id="关于View的布局"><a href="#关于View的布局" class="headerlink" title="关于View的布局"></a>关于View的布局</h2><p>直接使用CGRectMake的话可读性很差，光看那几个数字，也无法知道view和view之间的位置关系。用Autolayout可读性稍微好点儿，但生成Constraint的长度实在太长，代码观感不太好。</p>
<p>Autolayout这边可以考虑使用Masonry，代码的可读性就能好很多。如果还有使用Frame的，可以考虑一下<br><a href="https://github.com/casatwy/HandyAutoLayout" target="_blank" rel="external">使用这个项目</a>。</p>
<p>这个项目里面提供了Frame相关的方便方法(UIView+LayoutMethods)，里面的方法也基本涵盖了所有布局的需求，可读性非常好，使用它之后基本可以和CGRectMake说再见了。因为天猫在最近才切换到支持iOS6，所以之前天猫都是用Frame布局的，在天猫App中，首页，范儿部分页面的布局就使用了这些方法。使用这些方便方法能起到事半功倍的效果。</p>
<p>这个项目也提供了Autolayout方案下生产Constraints的方便方法(UIView+AEBHandyAutoLayout)，可读性比原生好很多。我当时在写这系列方法的时候还不知道有Masonry。知道有Masonry之后我特地去看了一下，发现Masonry功能果然强大。不过这系列方法虽然没有Masonry那么强大，但是也够用了。当时安居客iPad版App全部都是Autolayout来做的View布局，就是使用的这个项目里面的方法。可读性很好。</p>
<h2 id="何时使用storyboard，何时使用-nib-，何时使用代码写View"><a href="#何时使用storyboard，何时使用-nib-，何时使用代码写View" class="headerlink" title="何时使用storyboard，何时使用 nib ，何时使用代码写View"></a>何时使用storyboard，何时使用 nib ，何时使用代码写View</h2><p>这个问题唐巧的博客里<a href="http://blog.devtang.com/2015/03/22/ios-dev-controversy-2/" target="_blank" rel="external">这篇文章</a>。也提到过，我的意见和他是基本一致的。<br>具有一定规模的团队化iOS开发（10人以上）有以下几个特点：</p>
<p>同一份代码文件的作者会有很多，不同作者同时修改同一份代码的情况也不少见。因此，使用Git进行代码版本管理时出现Conflict的几率也比较大。<br>需求变化非常频繁，产品经理一时一个主意，为了完成需求而针对现有代码进行微调的情况，以及针对现有代码的部分复用的情况也比较多。<br>复杂界面元素、复杂动画场景的开发任务比较多。</p>
<h2 id="是否有必要让业务方统一派生ViewController"><a href="#是否有必要让业务方统一派生ViewController" class="headerlink" title="是否有必要让业务方统一派生ViewController"></a>是否有必要让业务方统一派生ViewController</h2><p>我觉得没有必要，为什么没有必要？</p>
<p>使用派生比不使用派生更容易增加业务方的使用成本<br>不使用派生手段一样也能达到统一设置的目</p>
<h2 id="关于MVC、MVVM等一大堆思想"><a href="#关于MVC、MVVM等一大堆思想" class="headerlink" title="关于MVC、MVVM等一大堆思想"></a>关于MVC、MVVM等一大堆思想</h2><p>其实这些都是相对通用的思想，万变不离其宗的还是在开篇里面我提到的那三个角色：数据管理者，数据加工者，数据展示者。这些五花八门的思想，不外乎就是制订了一个规范，规定了这三个角色应当如何进行数据交换。但同时这些也是争议最多的话题，所以我在这里来把几个主流思想做一个梳理，当你在做View层架构时，能够有个比较好的参考。</p>
<p>MVC（Model-View-Controller）是最老牌的的思想，老牌到4人帮的书里把它归成了一种模式，其中Model就是作为数据管理者，View作为数据展示者，Controller作为数据加工者，Model和View又都是由Controller来根据业务需求调配，所以Controller还负担了一个数据流调配的功能。正在我写<a href="http://www.infoq.com/cn/news/2015/04/symposium-web-mvc" target="_blank" rel="external">这篇文章</a>的时候，我看到InfoQ发了这篇文章，里面提到了一个移动开发中的痛点是：对MVC架构划分的理解。</p>
<p>在iOS开发领域，我们应当如何进行MVC的划分？</p>
<p>这里面其实有两个问题：</p>
<p>为什么我们会纠结于iOS开发领域中MVC的划分问题？<br>在iOS开发领域中，怎样才算是划分的正确姿势？<br>为什么我们会纠结于iOS开发领域中MVC的划分问题？</p>
<p>关于这个，每个人纠结的点可能不太一样，我也不知道当时座谈会上大家的观点。但请允许我猜一下：是不是因为UIViewController中自带了一个View，且控制了View的整个生命周期（viewDidLoad,viewWillAppear…），而在常识中我们都知道Controller不应该和View有如此紧密的联系，所以才导致大家对划分产生困惑？，下面我会针对这个猜测来给出我的意见。</p>
<p>在服务端开发领域，Controller和View的交互方式一般都是这样，比如Yii：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">...</span></div><div class="line"><span class="comment">数据库取数据</span></div><div class="line"><span class="comment">...</span></div><div class="line"><span class="comment">处理数据</span></div><div class="line"><span class="comment">...</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="comment">// 此处$this就是Controller</span></div><div class="line">$<span class="keyword">this</span>-&gt;render(<span class="string">"plan"</span>,array(</div><div class="line">'planList' =&gt; $planList,</div><div class="line">'plan_id' =&gt; $_GET['id'],</div><div class="line">));</div></pre></td></tr></table></figure>
<p>这里Controller和View之间区分得非常明显，Controller做完自己的事情之后，就把所有关于View的工作交给了页面渲染引擎去做，Controller不会去做任何关于View的事情，包括生成View，这些都由渲染引擎代劳了。这是一个区别，但其实服务端View的概念和Native应用View的概念，真正的区别在于：从概念上严格划分的话，服务端其实根本没有View，拜HTTP协议所赐，我们平时所讨论的View只是用于描述View的字符串（更实质的应该称之为数据），真正的View是浏览器。。</p>
<p>所以服务端只管生成对View的描述，至于对View的长相，UI事件监听和处理，都是浏览器负责生成和维护的。但是在Native这边来看，原本属于浏览器的任务也逃不掉要自己做。那么这件事情由谁来做最合适？苹果给出的答案是：UIViewController。</p>
<p>鉴于苹果在这一层做了很多艰苦卓绝的努力，让iOS工程师们不必亲自去实现这些内容。而且，它把所有的功能都放在了UIView上，并且把UIView做成不光可以展示UI，还可以作为容器的一个对象。</p>
<p>看到这儿你明白了吗？UIView的另一个身份其实是容器！UIViewController中自带的那个view，它的主要任务就是作为一个容器。如果它所有的相关命名都改成ViewContainer，那么代码就会变成这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewContainerDidLoad</div><div class="line">&#123;</div><div class="line">[<span class="keyword">self</span>.viewContainer addSubview:<span class="keyword">self</span>.label];</div><div class="line">[<span class="keyword">self</span>.viewContainer addSubview:<span class="keyword">self</span>.tableView];</div><div class="line">[<span class="keyword">self</span>.viewContainer addSubview:<span class="keyword">self</span>.button];</div><div class="line">[<span class="keyword">self</span>.viewContainer addSubview:<span class="keyword">self</span>.textField];</div><div class="line">&#125;</div><div class="line">... ...</div></pre></td></tr></table></figure>
<p>仅仅改了个名字，现在是不是感觉清晰了很多？如果再要说详细一点，我们平常所认为的服务端MVC是这样划分的：<br><img src="http://cc.cocimg.com/api/uploads/20150522/1432264217309340.jpg" class="[MVC]"></p>
<p>但事实上，整套流程的MVC划分是这样：<br><img src="http://cc.cocimg.com/api/uploads/20150522/1432264239743352.jpg" class="[MVC]"></p>
<p>由图中可以看出，我们服务端开发在这个概念下，其实只涉及M和C的开发工作，浏览器作为View的容器，负责View的展示和事件的监听。那么对应到iOS客户端的MVC划分上面来，就是这样：<br><img src="http://cc.cocimg.com/api/uploads/20150522/1432264253909859.jpg" class="[MVC]"></p>
<p>唯一区别在于，View的容器在服务端，是由Browser负责，在整个网站的流程中，这个容器放在Browser是非常合理的。在iOS客户端，View的容器是由UIViewController中的view负责，我也觉得苹果做的这个选择是非常正确明智的。</p>
<p>因为浏览器和服务端之间的关系非常松散，而且他们分属于两个不同阵营，服务端将对View的描述生成之后，交给浏览器去负责展示，然而一旦view上有什么事件产生，基本上是很少传递到服务器（也就是所谓的Controller）的（要传也可以：AJAX），都是在浏览器这边把事情都做掉，所以在这种情况下，View容器就适合放在浏览器（V）这边。</p>
<p>但是在iOS开发领域，虽然也有让View去监听事件的做法，但这种做法非常少，都是把事件回传给Controller，然后Controller再另行调度。所以这时候，View的容器放在Controller就非常合适。Controller可以因为不同事件的产生去很方便地更改容器内容，比如加载失败时，把容器内容换成失败页面的View，无网络时，把容器页面换成无网络的View等等。</p>
<p>在iOS开发领域中，怎样才算是MVC划分的正确姿势？</p>
<p>这个问题其实在上面已经解答掉一部分了，那么这个问题的答案就当是对上面问题的一个总结吧。</p>
<p>M应该做的事：</p>
<p>给ViewController提供数据<br>给ViewController存储数据提供接口<br>提供经过抽象的业务基本组件，供Controller调度<br>C应该做的事：</p>
<p>管理View Container的生命周期<br>负责生成所有的View实例，并放入View Container<br>监听来自View与业务有关的事件，通过与Model的合作，来完成对应事件的业务。<br>V应该做的事：</p>
<p>响应与业务无关的事件，并因此引发动画效果，点击反馈（如果合适的话，尽量还是放在View去做）等。<br>界面元素表达</p>
<p>我通过与服务端MVC划分的对比来回答了这两个问题，之所以这么做，是因为我知道有很多iOS工程师之前是从服务端转过来的。我也是这样，在进安居客之前，我也是做服务端开发的，在学习iOS的过程中，我也曾经对iOS领域的MVC划分问题产生过疑惑，我疑惑的点就是前面开篇我猜测的点。如果有人问我iOS中应该怎么做MVC的划分，我就会像上面这么回答。</p>
<h2 id="MVCS"><a href="#MVCS" class="headerlink" title="MVCS"></a>MVCS</h2><p>苹果自身就采用的是这种架构思路，从名字也能看出，也是基于MVC衍生出来的一套架构。从概念上来说，它拆分的部分是Model部分，拆出来一个Store。这个Store专门负责数据存取。但从实际操作的角度上讲，它拆开的是Controller。</p>
<p>这算是瘦Model的一种方案，瘦Model只是专门用于表达数据，然后存储、数据处理都交给外面的来做。MVCS使用的前提是，它假设了你是瘦Model，同时数据的存储和处理都在Controller去做。所以对应到MVCS，它在一开始就是拆分的Controller。因为Controller做了数据存储的事情，就会变得非常庞大，那么就把Controller专门负责存取数据的那部分抽离出来，交给另一个对象去做，这个对象就是Store。这么调整之后，整个结构也就变成了真正意义上的MVCS。</p>
<p>关于胖Model和瘦Model</p>
<p>我在面试和跟别人聊天时，发现知道胖Model和瘦Model的概念的人不是很多。大约两三年前国外业界曾经对此有过非常激烈的讨论，主题就是Fat model, skinny controller。现在关于这方面的讨论已经不多了，然而直到今天胖Model和瘦Model哪个更好，业界也还没有定论，所以这算是目前业界悬而未解的一个争议。我很少看到国内有讨论这个的资料，所以在这里我打算补充一下什么叫胖Model什么叫瘦Model。以及他们的争论来源于何处。</p>
<ul>
<li>什么叫胖Model？<br>胖Model包含了部分弱业务逻辑。胖Model要达到的目的是，Controller从胖Model这里拿到数据之后，不用额外做操作或者只要做非常少的操作，就能够将数据直接应用在View上。举个例子：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Raw Data:</div><div class="line">timestamp:<span class="number">1234567</span></div><div class="line">FatModel:</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> timestamp;</div><div class="line">- (<span class="built_in">NSString</span> *)ymdDateString; <span class="comment">// 2015-04-20 15:16</span></div><div class="line">- (<span class="built_in">NSString</span> *)gapString; <span class="comment">// 3分钟前、1小时前、一天前、2015-3-13 12:34</span></div><div class="line">Controller:</div><div class="line"><span class="keyword">self</span>.dateLabel.text = [FatModel ymdDateString];</div><div class="line"><span class="keyword">self</span>.gapLabel.text = [FatModel gapString];</div></pre></td></tr></table></figure>
<p>把timestamp转换成具体业务上所需要的字符串，这属于业务代码，算是弱业务。FatModel做了这些弱业务之后，Controller就能变得非常skinny，Controller只需要关注强业务代码就行了。众所周知，强业务变动的可能性要比弱业务大得多，弱业务相对稳定，所以弱业务塞进Model里面是没问题的。另一方面，弱业务重复出现的频率要大于强业务，对复用性的要求更高，如果这部分业务写在Controller，类似的代码会洒得到处都是，一旦弱业务有修改（弱业务修改频率低不代表就没有修改），这个事情就是一个灾难。如果塞到Model里面去，改一处很多地方就能跟着改，就能避免这场灾难。</p>
<p>然而其缺点就在于，胖Model相对比较难移植，虽然只是包含弱业务，但好歹也是业务，迁移的时候很容易拔出萝卜带出泥。另外一点，MVC的架构思想更加倾向于Model是一个Layer，而不是一个Object，不应该把一个Layer应该做的事情交给一个Object去做。最后一点，软件是会成长的，FatModel很有可能随着软件的成长越来越Fat，最终难以维护。</p>
<ul>
<li>什么叫瘦Model？<br>瘦Model只负责业务数据的表达，所有业务无论强弱一律扔到Controller。瘦Model要达到的目的是，尽一切可能去编写细粒度Model，然后配套各种helper类或方法来对弱业务做抽象，强业务依旧交给Controller。举个例子：<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Raw Data:</div><div class="line">&#123;</div><div class="line"><span class="string">"name"</span>:<span class="string">"casa"</span>,</div><div class="line"><span class="string">"sex"</span>:<span class="string">"male"</span>,</div><div class="line">&#125;</div><div class="line">SlimModel:</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *sex;</div><div class="line">Helper:</div><div class="line"><span class="meta">#define Male 1;</span></div><div class="line"><span class="meta">#define Female 0;</span></div><div class="line">+ (<span class="built_in">BOOL</span>)sexWithString:(<span class="built_in">NSString</span> *)sex;</div><div class="line">Controller:</div><div class="line"><span class="keyword">if</span> ([Helper sexWithString:SlimModel.sex] == Male) &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
由于SlimModel跟业务完全无关，它的数据可以交给任何一个能处理它数据的Helper或其他的对象，来完成业务。在代码迁移的时候独立性很强，很少会出现拔出萝卜带出泥的情况。另外，由于SlimModel只是数据表达，对它进行维护基本上是0成本，软件膨胀得再厉害，SlimModel也不会大到哪儿去。</li>
</ul>
<p>缺点就在于，Helper这种做法也不见得很好，这里有一篇文章批判了这个事情。另外，由于Model的操作会出现在各种地方，SlimModel在一定程度上违背了DRY（Don’t Repeat Yourself）的思路，Controller仍然不可避免在一定程度上出现代码膨胀。</p>
<p>我的态度？嗯，我会在本门心法这一节里面说。</p>
<p>说回来，MVCS是基于瘦Model的一种架构思路，把原本Model要做的很多事情中的其中一部分关于数据存储的代码抽象成了Store，在一定程度上降低了Controller的压力。</p>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM去年在业界讨论得非常多，无论国内还是国外都讨论得非常热烈，尤其是在ReactiveCocoa这个库成熟之后，ViewModel和View的信号机制在iOS下终于有了一个相对优雅的实现。MVVM本质上也是从MVC中派生出来的思想，MVVM着重想要解决的问题是尽可能地减少Controller的任务。不管MVVM也好，MVCS也好，他们的共识都是Controller会随着软件的成长，变很大很难维护很难测试。只不过两种架构思路的前提不同，MVCS是认为Controller做了一部分Model的事情，要把它拆出来变成Store，MVVM是认为Controller做了太多数据加工的事情，所以MVVM把数据加工的任务从Controller中解放了出来，使得Controller只需要专注于数据调配的工作，ViewModel则去负责数据加工并通过通知机制让View响应ViewModel的改变。</p>
<p>MVVM是基于胖Model的架构思路建立的，然后在胖Model中拆出两部分：Model和ViewModel。关于这个观点我要做一个额外解释：胖Model做的事情是先为Controller减负，然后由于Model变胖，再在此基础上拆出ViewModel，跟业界普遍认知的MVVM本质上是为Controller减负这个说法并不矛盾，因为胖Model做的事情也是为Controller减负。</p>
<p>另外，我前面说MVVM把数据加工的任务从Controller中解放出来，跟MVVM拆分的是胖Model也不矛盾。要做到解放Controller，首先你得有个胖Model，然后再把这个胖Model拆成Model和ViewModel。</p>
<p>那么MVVM究竟应该如何实现？</p>
<p>在iOS领域大部分MVVM架构都会使用ReactiveCocoa，但是使用ReactiveCocoa的iOS应用就是基于MVVM架构的吗？那当然不是，我觉得很多人都存在这个误区</p>
<ul>
<li>MVVM的关键是要有View Model！而不是ReactiveCocoa(勘误2)</li>
</ul>
<p>ViewModel做什么事情？就是把RawData变成直接能被View使用的对象的一种Model。举个例子<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Raw Data:</div><div class="line">&#123;</div><div class="line">(</div><div class="line">(<span class="number">123</span>, <span class="number">456</span>),</div><div class="line">(<span class="number">234</span>, <span class="number">567</span>),</div><div class="line">(<span class="number">345</span>, <span class="number">678</span>)</div><div class="line">)</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>这里的RawData我们假设是经纬度，数字我随便写的不要太在意。然后你有一个模块是地图模块，把经纬度数组全部都转变成MKAnnotation或其派生类对于Controller来说是弱业务，（记住，胖Model就是用来做弱业务的），因此我们用ViewModel直接把它转变成MKAnnotation的NSArray，交给Controller之后Controller直接就可以用了。<br>嗯，这就是ViewModel要做的事情，是不是觉得很简单，看不出优越性？</p>
<p>安居客Pad应用也有一个地图模块，在这里我设计了一个对象叫做reformer（其实就是ViewModel），专门用来干这个事情。那么这么做的优越性体现在哪儿呢？</p>
<p>安居客分三大业务：租房、二手房、新房。这三个业务对应移动开发团队有三个API开发团队，他们各自为政，这就造成了一个结果：三个API团队回馈给移动客户端的数据内容虽然一致，但是数据格式是不一致的，也就是相同value对应的key是不一致的。但展示地图的ViewController不可能写三个，所以肯定少不了要有一个API数据兼容的逻辑，这个逻辑我就放在reformer里面去做了，于是业务流程就变成了这样：</p>
<img src="http://cc.cocimg.com/api/uploads/20150522/1432264253909859.jpg" class="[MVVC]">
<p>这么一来，原本复杂的MKAnnotation组装逻辑就从Controller里面拆分了出来，Controller可以直接拿着Reformer返回的数据进行展示。APIManager就属于Model，reformer就属于ViewModel。具体关于reformer的东西我会放在网络层架构来详细解释。Reformer此时扮演的ViewModel角色能够很好地给Controller减负，同时，维护成本也大大降低，经过reformer产出的永远都是MKAnnotation，Controller可以直接拿来使用。</p>
<p>然后另外一点，还有一个业务需求是取附近的房源，地图API请求是能够hold住这个需求的，那么其他地方都不用变，在fetchDataWithReformer的时候换一个reformer就可以了，其他的事情都交给reformer。</p>
<ul>
<li>那么ReactiveCocoa应该扮演什么角色？</li>
</ul>
<p>不用ReactiveCocoa也能MVVM，用ReactiveCocoa能更好地体现MVVM的精髓。前面我举到的例子只是数据从API到View的方向，View的操作也会产生”数据”，只不过这里的”数据”更多的是体现在表达用户的操作上，比如输入了什么内容，那么数据就是text、选择了哪个cell，那么数据就是indexPath。那么在数据从view走向API或者Controller的方向上，就是ReactiveCocoa发挥的地方。</p>
<p>我们知道，ViewModel本质上算是Model层（因为是胖Model里面分出来的一部分），所以View并不适合直接持有ViewModel，那么View一旦产生数据了怎么办？扔信号扔给ViewModel，用谁扔？ReactiveCocoa。</p>
<p>在MVVM中使用ReactiveCocoa的第一个目的就是如上所说，View并不适合直接持有ViewModel。第二个目的就在于，ViewModel有可能并不是只服务于特定的一个View，使用更加松散的绑定关系能够降低ViewModel和View之间的耦合度。</p>
<ul>
<li>那么在MVVM中，Controller扮演什么角色？</li>
</ul>
<p>大部分国内外资料阐述MVVM的时候都是这样排布的：View &lt;-&gt; ViewModel &lt;-&gt; Model，造成了MVVM不需要Controller的错觉，现在似乎发展成业界开始出现MVVM是不需要Controller的。的声音了。其实MVVM是一定需要Controller的参与的，虽然MVVM在一定程度上弱化了Controller的存在感，并且给Controller做了减负瘦身（这也是MVVM的主要目的）。但是，这并不代表MVVM中不需要Controller，MMVC和MVVM他们之间的关系应该是这样：<br><img src="http://cc.cocimg.com/api/uploads/20150522/1432261506429014.gif" class="[MVVC]"></p>
<p>View &lt;-&gt; C &lt;-&gt; ViewModel &lt;-&gt; Model，所以使用MVVM之后，就不需要Controller的说法是不正确的。严格来说MVVM其实是MVCVM。从图中可以得知，Controller夹在View和ViewModel之间做的其中一个主要事情就是将View和ViewModel进行绑定。在逻辑上，Controller知道应当展示哪个View，Controller也知道应当使用哪个ViewModel，然而View和ViewModel它们之间是互相不知道的，所以Controller就负责控制他们的绑定关系，所以叫Controller/控制器就是这个原因。<br>前面扯了那么多，其实归根结底就是一句话：在MVC的基础上，把C拆出一个ViewModel专门负责数据处理的事情，就是MVVM。然后，为了让View和ViewModel之间能够有比较松散的绑定关系，于是我们使用ReactiveCocoa，因为苹果本身并没有提供一个比较适合这种情况的绑定方法。iOS领域里KVO，Notification，block，delegate和target-action都可以用来做数据通信，从而来实现绑定，但都不如ReactiveCocoa提供的RACSignal来的优雅，如果不用ReactiveCocoa，绑定关系可能就做不到那么松散那么好，但并不影响它还是MVVM。</p>
<p>在实际iOS应用架构中，MVVM应该出现在了大部分创业公司或者老牌公司新App的iOS应用架构图中，据我所知易宝支付旗下的某个iOS应用就整体采用了MVVM架构，他们抽出了一个Action层来装各种ViewModel，也是属于相对合理的结构。</p>
<p>所以Controller在MVVM中，一方面负责View和ViewModel之间的绑定，另一方面也负责常规的UI逻辑处理。</p>
<h2 id="VIPER"><a href="#VIPER" class="headerlink" title="VIPER"></a>VIPER</h2><p>VIPER（View，Interactor，Presenter，Entity，Routing）。VIPER我并没有实际使用过，我是在objc.io上第13期看到的。</p>
<p>但凡出现一个新架构或者我之前并不熟悉的新架构，有一点我能够非常肯定，这货一定又是把MVC的哪个部分给拆开了（坏笑，做这种判断的理论依据在第一篇文章里面我已经讲过了）。事实情况是VIPER确实拆了很多很多，除了View没拆，其它的都拆了。</p>
<p>我提到的这两篇文章关于VIPER都讲得很详细，一看就懂。但具体在使用VIPER的时候会有什么坑或者会有哪些争议我不是很清楚，硬要写这一节的话我只能靠YY，所以我想想还是算了。</p>
<p>MVC其实是非常高Level的抽象，意思也就是，在MVC体系下还可以再衍生无数的架构方式，但万变不离其宗的是，它一定符合MVC的规范。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/18/iOS-Node/" data-id="cj7ltd60p0004s16f90eif3iy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/09/15/细说-synchronized和dispatch-once/">细说@synchronized和dispatch_once</a>
          </li>
        
          <li>
            <a href="/2017/09/14/SDWebImage源码剖析(一)/">SDWebImage源码剖析(一)</a>
          </li>
        
          <li>
            <a href="/2017/09/01/CoreAnimation/">CoreAnimation</a>
          </li>
        
          <li>
            <a href="/2017/07/18/ iOS应用程序间共享数据/">iOS应用程序间共享数据</a>
          </li>
        
          <li>
            <a href="/2017/06/18/iOS-Node/">iOS Node(架构篇)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 lxq<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>